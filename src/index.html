<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yesiamrocks/cssanimation.io@1.0.3/cssanimation.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/shakrmedia/tuesday@v1.1.0/build/tuesday.min.css" />
    <title>Animation assistant</title>
</head>
<style>
    * {
        box-sizing: inherit;
    }
    html {
        font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
        font-size: 16px;
        box-sizing: border-box;
    }
    body {
        margin: 0;
        background-color: black;
        color: #d9d9d9;
    }
    pre {
        overflow-x: auto;
        display: flex;
        border: 1px solid;
        border-radius: 10px;
        background-color: #272727;
        box-shadow: 0 0 3px 1px #646668;
    }
    code {
        color: #b5b5b5;
    }
    a {
        text-decoration: none;
        color: #3db9e7;
    }
    .container {
        max-width: 1400px;
        margin: 30px auto;
        padding: 20px;
        background-color: #1b1b1b;
        border-radius: 5px;
        box-shadow: 0 0 5px floralwhite;
    }
    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid teal;
        margin-bottom: 10px;
    }
    .section-demonstration {
        display: flex;
        flex-wrap: wrap;
        padding: 50px 0;
    }
    .footer {
        text-align: right;
    }
    .heading {
        display: inline-block;
        margin: 0;
        padding-bottom: 10px;
        color: #74c4e3;
    }
    .heading-header {
        margin-bottom: 10px;
    }
    .text {
        margin: 0;
        padding-bottom: 10px;
        line-height: 1.6;
    }
    .block {
        flex-basis: 40%;
        flex-grow: 1;
        border: 1px solid darkgrey;
        border-radius: 5px;
        margin-left: 5%;
        margin-right: 5%;
        margin-bottom: 10px;
        padding: 10px;
        background-color: #130523;
    }
    .info {
        padding: 0 5px;
        background-color: #0b232f;
        color: #ca83e7;
        border-radius: 5px;
        box-shadow: 0 0 1px 1px #b8aae8;
    }
    .git,
    .npm {
        padding: 0.25rem;
    }
    .npm {
        padding-right: 0.35rem;
    }
    .notice {
        margin-bottom: 10px;
        border: 1px solid #a66511;
        padding: 10px;
        border-radius: 10px;
        background-color: #0c101a;
        box-shadow: 0 0 3px 2px #4f491d;
    }
    .notice-text {
        margin: 0;
    }
    .button {
        display: block;
        max-width: 200px;
        border: 1px solid #053344;
        outline: none;
        margin-bottom: 10px;
        padding: 5px 10px;
        font-family: inherit;
        font-size: inherit;
        border-radius: 5px;
        text-transform: uppercase;
        user-select: none;
        cursor: pointer;
    }
    .ul {
        margin: 0 0 10px;
        padding: 0;
        list-style-position: inside;
        list-style-type: circle;
    }
    .link-item {
        text-decoration: none;
        color: #a417d2;
    }
    .link-item:active {
        color: #a417d2;
    }
    .code-comment {
        color: #909090;
    }
    .code-new {
        color: #e141af;
    }
    .d-block {
        display: block !important;
    }
</style>
<body>

<div class="container">
    <header class="header">
        <div>
            <span class="npm">
            <a href="">NPM</a>
        </span>
            <span class="git">
            <a href="">GIT</a>
        </span>
        </div>
        <h1 class="heading heading-header info animateCssPlay">Animation Assistant</h1>
    </header>

    <main class="main">
        <section class="section">
<!--            <div class="section-demonstration">-->
<!--                <div class="block animation-css-example-play">-->
<!--                    <h2 class="heading">animate.css</h2>-->
<!--                    <p class="text">-->
<!--                        Результат выполнения метода play объекта <span class="info">animationCssExamplePlay</span>.-->
<!--                    </p>-->
<!--                </div>-->
<!--                <div class="block animation-css-example-play">-->
<!--                    <h2 class="heading">animate.css</h2>-->
<!--                    <p class="text">-->
<!--                        Результат выполнения метода play объекта <span class="info">animationCssExamplePlay</span>.-->
<!--                    </p>-->
<!--                </div>-->
<!--            </div>-->
            <h2 class="heading">Введение</h2>
            <p class="text">
                Плагин <span class="info">animation-assistant</span> помогает работать с анимацией.
                Плагин работает со многими известными библиотеками CSS:
            </p>

            <ul class="ul">
                <li class="list-item"><a class="link-item" href="#animate.css">animate.css 4.0.0^</a></li>
                <li class="list-item"><a class="link-item" href="#cssanimation">cssanimation 1.0.0^</a></li>
                <li class="list-item"><a class="link-item" href="#hover.css">hover.css 2.0.0^</a></li>
                <li class="list-item"><a class="link-item" href="#CSShake">CSShake 1.5.0^</a></li>
                <li class="list-item"><a class="link-item" href="#magic.css">magic.css 1.1.0^</a></li>
                <li class="list-item"><a class="link-item" href="#tuesday">tuesday 1.2.0^</a></li>
                <li class="list-item"><a class="link-item" href="#repaintless">repaintless 1.3.0^</a></li>
                <li class="list-item"><a class="link-item" href="#other">Возможно, ваша любимая библиотека CSS анимации</a></li>
                <li class="list-item"><a class="link-item" href="#other">Работа со своей анимацией через плагин</a></li>
            </ul>

            <h2 class="heading">Начало работы</h2>

            <p class="text">
                Установите плагин в ваш проект используя NPM
            </p>

            <pre>
            <code>
    npm install --save animation-assistant
            </code>
            </pre>

            <p class="text">
                Подключите его удобным вам способом:
            </p>

            <p class="text">
                CommonJS:
            </p>

            <pre>
            <code>
    const AnimationAssistant = require('AnimationAssistant');
            </code>
            </pre>

            <p class="text">
                ESM:
            </p>

            <pre>
            <code>
    import AnimationAssistant from 'AnimationAssistant';
            </code>
            </pre>

            <p class="text">
                Для начала необходимо получить экземпляр класса <span class="info">AnimationAssistant</span> вызвав соответствующий
                конструктор и передав ему CSS селектор. Например:
            </p>

            <p>HTML</p>

            <pre>
            <code>
    &lt;div class="forAnimation">  &lt;/div>
            </code>
            </pre>

            <p>JavaScript</p>

            <pre>
            <code>
    const animation = new AnimationAssistant('selector');
            </code>
            </pre>

            <p class="text">
                Это может быть как один элемент так и группа элементов:
            </p>

            <p>HTML</p>

            <pre>
            <code>
    &lt;div class="your-class">    &lt;/div>
    &lt;div class="your-class">    &lt;/div>
    &lt;div class="your-class">    &lt;/div>
            </code>
            </pre>

            <p>JavaScript</p>

            <pre>
            <code>
    const animation = new AnimationAssistant('your-class');
            </code>
            </pre>

            <p class="text">
                <span class="info">animation.setLibrary(library: string): animation</span> - Принимает один аргумент в виде строки.
                Возвращает текущий экземпляр класса. Подготавливает выбранную CSS библиотеку для работы.
                Опциональный метод, который устанавливает выбранную вами библиотеку для работы с анимацией
                добавляя необходимый префикс к элементам.
            </p>

            <p class="text">
                <span class="info">animation.addClasses(array[]:string): animation</span> - Принимает массив с классами и добавляет их к элементам.
                Возвращает текущий экземпляр класса.
            </p>

            <p class="text">
                <span class="info">animation.hiddenLaunch(void): animation</span> - Скрывает элемент до начала анимации.
                Возвращает текущий экземпляр класса.
            </p>

            <p class="text">
                <span class="info">animation.adaptEnvironment({ pass: string, exclude: array[]:string } | void): animation</span> -
                Принимает объект с настройками. Поле pass означает, что нужно перекинуть все классы с текущего элемента на родительский.
                Поле exclude это массив с классами, которые не будут переброшены. Передача пустого значения будет означать отсутствие
                переброса классов. Адаптирует окружение элемента для корректной работы анимаций. Возвращает текущий экземпляр класса.
            </p>

            <p class="text">
                <span class="info">animation.setAnimation(offset: number, name: string, animationEnd: function): animation</span> -
                offset - это значение от 1 до 100 (%) относительно верхнего края элемента до верхнего края окна пользователя. Параметр name -
                это текущий класс, который будет задействован по сигналу от параметра offset. Параметр animationEnd запустит функцию
                после окончания анимации. Настраивает анимацию для работы. Возвращает текущий экземпляр класса.
                Функция обратного вызова <span class="info">animationEnd</span> может вернуть другую функцию обратного вызова со
                следующей сигнатурой: <span class="info">animationEndCallback(current: HTMLElement): void</span>, где current -
                это текущий элемент.
            </p>

            <p class="text">
                <span class="info">animation.play(name: string, timeout: number): Promise</span> - name - это текущий класс,
                который будет применен к элементу, timeout задает время до запуска следующей анимации. Запускает анимацию.
                Возвращает Promise.
            </p>

            <h2 class="heading">Информация о работе плагина</h2>

            <p class="text">
                Метод <span class="info">setLibrary</span> является опциональным и может быть заменен методом <span class="info">addClasses</span>.
            </p>

            <p class="text">
                Все методы за исключение <span class="info">play</span> возвращают тот-же объект. Вы можете совершать цепочки вызовов.
            </p>

            <p class="text">
                Метод <span class="info">play</span> является асинхронным и возвращает Promise. Используйте его для анимаций элементов на
                стартовом экране или в собственных событиях для привлечения внимания пользователей к элементу. При этом в обработчике событий
                рекомендуется использовать поле <span class="info">once: true</span>.
            </p>

            <p class="text">
                Метод <span class="info">setAnimation</span> настраивает параметр <span class="info">offset</span> только для элементов,
                которые будут встречаться при прокрутке вниз. Если прокручивать страницу вверх данный параметр будет проигнорирован а
                элемент будет использовать анимацию сразу как только его нижний край сравняется с верхним края окна браузера.
            </p>

            <p class="text">
                Методы <span class="info">setAnimation</span> и <span class="info">play</span> должны вызываться самыми последними для более
                корректной работы плагина.
            </p>

            <h2 class="heading">Советы</h2>

            <p class="text">
                Не используйте анимацию на корневом элементе или на <span class="info">BODY</span>. Это возможно, но делать этого не следует.
            </p>

            <p class="text">
                Не используйте анимацию просто так. Анимация - это элемент взаимодействия с пользователем на сайте. Анимацией можно привлечь
                внимание, напомнить что либо или дать понять что действие было выполнено.
            </p>

            <p class="text">
                Используйте одну библиотеку. Плагин поддерживает разные библиотеки, но не стоит использовать их все разом. Не желательно
                использовать более одной библиотеки на сайте.
            </p>

            <p class="text">
                Метод <span class="info">setAnimation</span> назначает обработчик события <span class="info">scroll</span> на каждый элемент
                с которым работает. Помните, что если вы имеете на сайте 10 экземпляров объекта <span class="info">AnimationAssistant</span>
                и в каждом из них по 10 элементов, то у вас в наличии будет 100 обработчиков на объекте <span class="info">window</span>.
                Это вопрос производительности. Плагин будет удалять завершенные обработчики с документа.
            </p>

            <p class="text">
                Чаще всего вы захотите использовать параметр <span class="info">offset</span> в значении 100. В этой позиции элемент будет
                использовать анимацию сразу после того, как его верхний край сравняется с нижним краем окна браузера. В большинстве случаев
                это то что нам нужно, так как пользователи могу прокручивать страницу очень быстро и просто не заметить анимации, если этот
                параметр будет установлен в более низком значении, например 10 или 20.
            </p>

            <p class="text">
                Библиотека может предоставить анимацию, которая будет в бесконечном режиме. В этом случае вы должны быть готовы к ряду ограничений
                среди которых некорректная работа метода <span class="info">play</span> и невозможность вызвать callback функцию в методе
                <span class="info">setAnimation</span>.
            </p>

            <p class="text">
                Если вы не хотите чтобы анимация проигрывалась на планшетных устройствах или мобильных телефонах, тогда добавьте в CSS класс,
                который вы использовали при выборке элементов плагином и задайте ему два поля на интересующей вас точке останова -
                <span class="info">visibility: visible !important</span> и <span class="info">animation-name: none !important</span>.
                Например, у вас есть селектор классов <span class="info">for-animation</span> и вы отталкиваетесь от этого при использовании
                плагина:
            </p>

            <pre>
            <code>
    const myAnimation = new AnimationAssistant('for-animation');
    myAnimation.setLibrary('library');
    myAnimation.setAnimation(...settings);
            </code>
            </pre>

            <p class="text">
                Вы не хотите чтобы эта анимация проигрывалась на устройствах размеры экрана которых меньше 670px. Просто добавьте следующие
                правила в css:
            </p>

            <pre>
            <code>
    @media screen and (max-width: 670px) {
        .for-animation {
            visibility: visible !important;
            animation-name: none !important;
        }
    }
            </code>
            </pre>

            <h2 class="heading" id="animate.css">animate.css</h2>
            <p class="text">
               Для начала работы с библиотекой <span class="info">animate.css</span> следует создать новый экземпляр класса и
               вызвать метод <span class="info">setLibrary</span>:
            </p>

            <pre>
            <code>
    const animation = new AnimationAssistant('animation-css-example-play');
    animation.setLibrary('animate.css');
            </code>
            </pre>

            <p class="text">
                Затем можно вызвать метод <span class="info">play</span> и проиграть анимацию. Метод принимает
                имя анимации и количество миллисекунд для запуска следующей анимации.
            </p>

            <pre>
            <code>
    const animation = new AnimationAssistant('animation-css');
    animation.setLibrary('animate.css');
    <span class="code-new">const button = document.querySelector('button');
    button.addEventListener(
        'click',
        () => {
            animation
                .play('animate__headShake', 2200)
                .then((res) => res('animate__rubberBand', 4000))
                .then((res) => res('animate__tada'));
        },
        { once: true },
    );
            </span>
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block animation-css-example-play">
                    <h2 class="heading">animate.css</h2>
                    <p class="text">
                        Результат выполнения метода play.
                    </p>
                </div>
                <div class="block animation-css-example-play">
                    <h2 class="heading">animate.css</h2>
                    <p class="text">
                        Результат выполнения метода play.
                    </p>
                </div>
            </div>

            <button class="button">Кликни меня</button>

            <p class="text">
                Теперь при нажатии на клавишу срабатывает анимация. Из-за асинхронного характера работы метода <span class="info">play</span>
                лучше запускать такой обработчик один раз с флагом <span class="info">once: true</span>. В противном случае анимация может
                повести себя некорректно при многократном нажатии.
            </p>

            <p class="text">
                Количество анимаций применяемых методом <span class="info">play</span> ограничено только здравым смыслом.
            </p>

            <p class="text">
                Если вы хотите настроить CSS анимацию на срабатывание при прокрутке, тогда воспользуйтесь методом <span class="info">setAnimation</span>.
            </p>

            <pre>
            <code>
    const animation = new AnimationAssistant('animation-css');
    animation.setLibrary('animate.css');
    animation.setAnimation(40, 'animate__backInRight');
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block animation-css-example-set-animation">
                    <h2 class="heading">animate.css</h2>
                    <p class="text">
                        Результат выполнения метода setAnimation.
                    </p>
                </div>
                <div class="block animation-css-example-set-animation">
                    <h2 class="heading">animate.css</h2>
                    <p class="text">
                        Результат выполнения метода setAnimation.
                    </p>
                </div>
            </div>

            <p class="text">
                Элементы можно скрыть до начала анимации и подготовить родительский элемент к анимации:
            </p>

            <pre>
            <code>
    const animation = new AnimationAssistant('animation-css');
    animation.setLibrary('animate.css');
    <span class="code-new">animation.adaptEnvironment();
    animation.hiddenLaunch();</span>
    animation.setAnimation(40, 'animate__backInRight');
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block animation-css-example-set-animation2">
                    <h2 class="heading">animate.css</h2>
                    <p class="text">
                        Результат выполнения метода setAnimation. Теперь все работает корректно.
                    </p>
                </div>
                <div class="block animation-css-example-set-animation2">
                    <h2 class="heading">animate.css</h2>
                    <p class="text">
                        Результат выполнения метода setAnimation объекта. Теперь все работает корректно.
                    </p>
                </div>
            </div>

            <p class="text">
                Иногда понадобиться дополнительные классы. Например, для библиотеки <span class="info">animate.css</span> это могут быть
                <span class="info">animate__slower</span> для более медленного проигрывания анимации. Добавлением классов занимается метод
                <span class="info">addClasses</span>.
            </p>

            <pre>
            <code>
            const animation = new AnimationAssistant('animation-css-example-add-classes');
            <span class="code-new">animation.addClasses(['animate__slower', 'animate__repeat-2']);</span>
            animation.adaptEnvironment();
            animation.hideAtStart();
            animation.setAnimation(20, 'animate__backInRight');
            </code>
            </pre>

            <p class="text">
                Так-же не забывайте про callback функцию, которая выполнится после завершения анимации. Вы можете передать ее третьим параметром:
            </p>

            <pre>
            <code>
            const animation = new AnimationAssistant('animation-css');
            animation.addClasses(['animate__slow']);
            animation.adaptEnvironment();
            animation.hideAtStart();
            animation.setAnimation(30, 'animate__bounceInLeft', <span class="code-new">() => {
                <span class="code-comment">// ваш код, который будет выполнен после завершения анимации animate__bounceInLe</span>
                <span class="code-comment">// выполнится единожды, даже если задано повторение анимации</span>
                <span class="code-comment">// например при помощи класса animate__repeat-2 библиотеки animate.css</span>
                <span class="code-comment">// помните, что если анимация находится в бесконечном режиме (infinity),</span>
                <span class="code-comment">// то этот код не выполнится никогда</span>
                return () => {
                    <span class="code-comment">// этот код будет выполнен самым последним после выполнения всего кода</span>
                    <span class="code-comment">// включая метод play и все его then</span>
                };
            });
            </span>
            </code>
            </pre>

            <p class="text">
                Полный функционал плагина на примере библиотеки animate.css смотрите ниже:
            </p>

            <div class="section-demonstration">
                <div class="block animation-css-example-add-classes">
                    <h2 class="heading">animate.css</h2>
                    <p class="text">
                        Результат выполнения метода <span class="info">addClasses</span> объекта <span class="info">animationCssExampleAddClasses</span>.
                    </p>
                </div>
                <div class="block animation-css-example-add-classes">
                    <h2 class="heading">animate.css</h2>
                    <p class="text">
                        Результат выполнения метода <span class="info">addClasses</span> объекта
                        <span class="info">animationCssExampleAddClasses</span>. Теперь все работает корректно.
                    </p>
                </div>
            </div>

            <pre>
            <code>
    new AnimationAssistant('animation-css-example-add-classes')
        .setLibrary('animate.css')
        .addClasses(['animate__slow'])
        .adaptEnvironment()
        .hiddenLaunch()
        .setAnimation(30, 'animate__bounceInLeft', async () => {
            <span class="code-comment">// тут можно сделать необходимые действия по завершении анимации animate__bounceInLeft</span>
            const data = await (await fetch('www.api.com')?.json());
            const element = document.querySelector('.selector');
            element.addEventListener('click', listener);
            return (target) => {
                <span class="code-comment">// эта функция будет вызвана самой последней, следовательно, здесь можно почистить код</span>
                <span class="code-comment">// например удалить обработчики и прокинуть объект данных, или что-нибудь еще</span>
                <span class="code-comment">// параметр target - это текущий элемент на котором была проиграна анимация</span>
                element.removeEventListener('click', listener);
                myFunction(data, target);
            };
        })
        .play('animate__bounce', 1500)
        .then((res) => res('animate__jello', 2500))
        .then((res) => res('animate__flipOutX'));
            </code>
            </pre>

            <h2 class="heading" id="cssanimation">cssanimation</h2>
            <p class="text">
                Для начала работы с библиотекой <span class="info">cssanimation</span> необходимо получить экземпляр объекта <span class="info">AnimationAssistant</span> и вызвать метод <span class="info">setLibrary</span>:
            </p>

            <pre>
            <code>
            const cssAnimationExample = new AnimationAssistant('cssanimation-example');
            cssAnimationExample.setLibrary('css-animation');
            </code>
            </pre>

            <p class="text">
                После этого можно приступать к установке анимации. Для этого можно перейти на официальный сайт библиотеки
                <a href="http://cssanimation.io/">cssanimation</a> и выбрать подходящую анимацию. Пусть это будет <span class="info">swingInBottom</span>. Установим параметр <span class="info">offset</span> на 20% и добавим метод <span class="info">hideAtStart</span>
            </p>

            <pre>
            <code>
            const cssAnimationExample = new AnimationAssistant('cssanimation-example');
            cssAnimationExample.setLibrary('css-animation');
            cssAnimationExample.hideAtStart();
            cssAnimationExample.setAnimation(20, 'swingInBottom');
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block cssanimation-example">
                    <h2 class="heading">cssanimation</h2>
                    <p class="text">
                        Результат выполнения метода <span class="info">setAnimation</span> объекта <span class="info">cssAnimationExample</span>.
                    </p>
                </div>
                <div class="block cssanimation-example">
                    <h2 class="heading">cssanimation</h2>
                    <p class="text">
                        Результат выполнения метода setAnimation объекта <span class="info">cssAnimationExample</span>.
                    </p>
                </div>
            </div>

            <p class="text">
                При работе с этой библиотекой следует обратить внимание на две важные особенности. Во первых многие ее анимации имеют свойство <span class="info">animation-iteration-count</span> со значением <span class="info">infinite</span>, а во вторых некоторые её анимации работают с элементами <span class="info">span</span>, которые вложены в контейнер. В самой документации они обозначаются с классом <span class="info">sequence</span>, который написан там только для удобства, что-бы понять когда анимация будет работать не с самим элементом, а с его потомками. Метод <span class="info">play</span> не будет работать, потому что предыдущая анимация никогда не закончится, следовательно новая не начнется.
            </p>

            <div class="notice">
                <p class="notice-text">
                    Например, в следующем примере callback функция не выполнится никогда, так как анимация длится вечно:
                </p>
            </div>

            <pre>
            <code>
            const cssAnimationExampleInfinity = new AnimationAssistant('cssanimation-example-infinity');
            cssAnimationExampleInfinity.setLibrary('css-animation');
            cssAnimationExampleInfinity.setAnimation(20, 'heartbeatFast', () => {
                <span class="code-comment">// эта функция не будет запущена</span>
            });
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block cssanimation-example-infinity">
                    <h2 class="heading">cssanimation</h2>
                    <p class="text">
                        Функция обратного вызова не сработает так как анимация длится вечно.
                    </p>
                </div>
                <div class="block cssanimation-example-infinity">
                    <h2 class="heading">cssanimation</h2>
                    <p class="text">
                        Функция обратного вызова не сработает так как анимация длится вечно.
                    </p>
                </div>
            </div>

            <div class="notice">
                <p class="notice-text">
                    В этом примере ничего не произойдет, так как анимация <span class="info">leFadeInLeft</span> работает не с самим элементом а с его потомками, которые являются элементами <span class="info">span</span>.
                </p>
            </div>

            <pre>
            <code>
            const cssAnimationExampleBreak = new AnimationAssistant('cssanimation-example-break');
            cssAnimationExampleBreak.setLibrary('css-animation');
            cssAnimationExampleBreak.setAnimation(20, 'leFadeInLeft');
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block cssanimation-example-break">
                    <h2 class="heading">cssanimation</h2>
                    <p class="text">
                        Не работает...
                    </p>
                </div>
                <div class="block cssanimation-example-break">
                    <h2 class="heading">cssanimation</h2>
                    <p class="text">
                        Не работает...
                    </p>
                </div>
            </div>

            <p class="text">
                То есть нам нужен сам элемент, которому будет задан класс <span class="info">leFadeInLeft</span> и его потомок, элемент <span class="info">span</span> на которого анимация будет воздействовать. Следует отметить, что одним элементом потомком здесь не обойтись, так как анимация <span class="info">leFadeInLeft</span> начинает пролистывать элементы слева - направо по очереди, то есть это должна быть группа элементов. В противном случае он просто вытянет элемент из левого угла целиком. HTML структура должна быть примерно следующей:
            </p>

            <pre>
            <code>
            &lt;div class="block cssanimation-example-sequence">
                &lt;span style="animation-delay: 100ms">c&lt;/span>
                &lt;span style="animation-delay: 200ms">s&lt;/span>
                &lt;span style="animation-delay: 300ms">s&lt;/span>
                &lt;span style="animation-delay: 400ms">a&lt;/span>
                &lt;span style="animation-delay: 500ms">n&lt;/span>
                &lt;span style="animation-delay: 600ms">i&lt;/span>
                &lt;span style="animation-delay: 700ms">m&lt;/span>
                &lt;span style="animation-delay: 800ms">a&lt;/span>
                &lt;span style="animation-delay: 900ms">t&lt;/span>
                &lt;span style="animation-delay: 1000ms">i&lt;/span>
                &lt;span style="animation-delay: 1100ms">o&lt;/span>
                &lt;span style="animation-delay: 1200ms">n&lt;/span>
            &lt;/div>
            </code>
            </pre>

            <div class="notice">
                <p class="notice-text">
                    <span class="info">animation-delay</span> тут тоже обязателен. Он должен увеличиваться, желательно на равные отрезки времени от начального элемента.
                </p>
            </div>

            <p class="text">
                JavaScript:
            </p>

            <pre>
            <code>
            const cssAnimationExampleSequence = new AnimationAssistant('cssanimation-example-sequence');
            cssAnimationExampleSequence.setLibrary('css-animation');
            cssAnimationExampleSequence.setAnimation(20, 'leFadeInLeft');
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block cssanimation-example-sequence">
                    <span style="animation-delay: 100ms">c</span>
                    <span style="animation-delay: 200ms">s</span>
                    <span style="animation-delay: 300ms">s</span>
                    <span style="animation-delay: 400ms">a</span>
                    <span style="animation-delay: 500ms">n</span>
                    <span style="animation-delay: 600ms">i</span>
                    <span style="animation-delay: 700ms">m</span>
                    <span style="animation-delay: 800ms">a</span>
                    <span style="animation-delay: 900ms">t</span>
                    <span style="animation-delay: 1000ms">i</span>
                    <span style="animation-delay: 1100ms">o</span>
                    <span style="animation-delay: 1200ms">n</span>
                </div>
                <div class="block cssanimation-example-sequence">
                    <span style="animation-delay: 100ms">c</span>
                    <span style="animation-delay: 200ms">s</span>
                    <span style="animation-delay: 300ms">s</span>
                    <span style="animation-delay: 400ms">a</span>
                    <span style="animation-delay: 500ms">n</span>
                    <span style="animation-delay: 600ms">i</span>
                    <span style="animation-delay: 700ms">m</span>
                    <span style="animation-delay: 800ms">a</span>
                    <span style="animation-delay: 900ms">t</span>
                    <span style="animation-delay: 1000ms">i</span>
                    <span style="animation-delay: 1100ms">o</span>
                    <span style="animation-delay: 1200ms">n</span>
                </div>
            </div>

            <h2 class="heading" id="hover.css">hover.css</h2>

            <p class="text">
                При работе с этой библиотекой вам следует учитывать два важных нюанса. Первый - эта библиотека не предназначена для CSS анимаций в том виде в каком вы их видели ранее, она отвечает за такие состояния элемента как <span class="info">:hover</span>, <span class="info">:focus</span> и <span class="info">:active</span>. Второй - при работе с ней не обязательно вызывать метод <span class="info">setLibrary</span>.
            </p>

            <p class="text">
                Библиотека предназначена для изменения состояния элемента при активном состоянии, наведении или фокусировке.
                Мы можем использовать ее вызвав метод <span class="info">play</span> один раз с нулевой задержкой.
            </p>

            <p class="text">
                Для начала получим новый экземпляр объекта передав туда интересующий нас селектор а затем вызовем метод для работы с этой библиотекой. Список всех анимаций для работы с этой библиотекой можно посмотреть на их сайте <a href="http://ianlunn.github.io/Hover/">hover.css/demo</a>.
            </p>

            <pre>
            <code>
            const hoverCss = new AnimationAssistant('hover-css');
            hoverCss.play('hvr-bounce-in', 0).catch((err) => {
                throw new Error(err);
            });
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block hover-css">
                    <h2 class="heading">hover.css</h2>
                    <p class="text">
                        Наведи на меня (hvr-bounce-in)
                    </p>
                </div>
                <div class="block hover-css">
                    <h2 class="heading">hover.css</h2>
                    <p class="text">
                        Наведи на меня (hvr-bounce-in)
                    </p>
                </div>
            </div>

            <pre>
            <code>
            const hoverCssToLeft = new AnimationAssistant('hover-css-to-left');
            hoverCssToLeft.play('hvr-bounce-to-left', 0).catch((err) => {
                throw new Error(err);
            });
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block hover-css-to-left">
                    <h2 class="heading">hover.css</h2>
                    <p class="text">
                        Наведи на меня (hvr-bounce-to-left)
                    </p>
                </div>
                <div class="block hover-css-to-left">
                    <h2 class="heading">hover.css</h2>
                    <p class="text">
                        Наведи на меня (hvr-bounce-to-left)
                    </p>
                </div>
            </div>

            <pre>
            <code>
            const hoverCssCurlTopRight = new AnimationAssistant('hover-css-curl-top-right');
            hoverCssCurlTopRight.play('hvr-curl-top-right', 0).catch((err) => {
                throw new Error(err);
            });
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block hover-css-curl-top-right">
                    <h2 class="heading">hover.css</h2>
                    <p class="text">
                        Наведи на меня (hvr-curl-top-right)
                    </p>
                </div>
                <div class="block hover-css-curl-top-right">
                    <h2 class="heading">hover.css</h2>
                    <p class="text">
                        Наведи на меня (hvr-curl-top-right)
                    </p>
                </div>
            </div>

            <div class="notice">
                <p class="notice-text">
                    В библиотеке предусмотрены отдельные анимации для иконок. Что-бы узнать больше читайте - <a href="https://ianlunn.co.uk/articles/hover-css-tutorial-introduction">официальную документацию</a>
                </p>
            </div>

            <p class="text">
                Библиотека проста в использовании и для примеров приведенных выше не обязательно использовать данный плагин. Но вы можете использовать метод <span class="info">setAnimation</span> со значение <span class="info">offset</span> равное 100 и запустить callback функцию после завершения анимации.
            </p>

            <pre>
            <code>
            const hoverCssSetAnimation = new AnimationAssistant('hover-css-set-animation');
            hoverCssSetAnimation.setAnimation(100, 'hvr-wobble-top', () => {
                <span class="code-comment">// ваш код</span>
                <span class="code-comment">// сработает сразу после завершения анимации</span>
                <span class="code-comment">// если у анимации бесконечная продолжительность</span>
                <span class="code-comment">// а в этой библиотеке есть и такие</span>
                <span class="code-comment">// то этот код не выполнится никогда</span>
            });
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block hover-css-set-animation">
                    <h2 class="heading">hover.css</h2>
                    <p class="text">
                        Наведи на меня (hvr-curl-top-right)
                    </p>
                </div>
                <div class="block hover-css-set-animation">
                    <h2 class="heading">hover.css</h2>
                    <p class="text">
                        Наведи на меня (hvr-curl-top-right)
                    </p>
                </div>
            </div>

            <h2 class="heading" id="CSShake">CSShake</h2>

            <p class="text">
                Библиотека в основном предназначена для анимации элементов при наведении, но ею можно воспользоваться и при других событиях. Вызов метода <span class="info">setLibrary</span> не является обязательным при работе с данной библиотекой.
            </p>

            <p class="text">
                Вот простой пример использования библиотеки с данным плагином:
            </p>

            <pre>
            <code>
            const cssShake = new AnimationAssistant('css-shake');
            cssShake.setLibrary('css-shake'); <span class="code-comment">// можно опустить</span>
            cssShake.play('shake-slow', 0).catch((err) => {
                throw new Error(err);
            });
            </code>
            </pre>

            <p class="text">
                Мы вазвали метод <span class="info">play</span> с нулевой задержкой и нужной нам анимацией. Список доступных нам анимаций можно посмотреть <a href="http://elrumordelaluz.github.io/csshake/">на их сайте</a>.
            </p>

            <div class="section-demonstration">
                <div class="block css-shake">
                    <h2 class="heading">CSShake</h2>
                    <p class="text">
                        Наведи на меня (shake-slow)
                    </p>
                </div>
                <div class="block css-shake">
                    <h2 class="heading">CSShake</h2>
                    <p class="text">
                        Наведи на меня (shake-slow)
                    </p>
                </div>
            </div>

            <div class="notice">
                <p class="notice-text">
                    Классы этой библиотеки добавляют к элементу два свойства <span class="info">display: inherit;</span> и <span class="info">transform-origin: center center;</span>. Если последний не должен нас волновать, то изменения свойства <span class="info">display</span> на элементе может привести к его некорректному отображению. Два блока выше из-за этого отобразились не так как предполагалось. Имейте это в виду.
                </p>
            </div>

            <p class="text">
                У данной библиотеки имеется один вспомогательный класс для бесконечной анимации - <span class="info">shake-constant</span>. Мы можем воспользоваться методом <span class="info">addClasses</span> и добавить его к интересующим нам элементам. Особенность этого класса заключается еще и в том, что он не привязан к событию <span class="info">:hover</span>. Это означает, что мы можем воспользоваться методом <span class="info">setAnimation</span> для более гибкой настройки.
            </p>

            <pre>
            <code>
            const cssShakeChunk = new AnimationAssistant('css-shake-chunk');
            cssShakeChunk.addClasses(['shake-constant']); <span class="code-comment">// это всегда должен быть массив</span>
            cssShakeChunk.setAnimation(20, 'shake-chunk', () => {
                <span class="code-comment">// этот код не выполнится никогда</span>
                <span class="code-comment">// так как анимация никогда не закончится</span>
            });
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block d-block css-shake-chunk">
                    <h2 class="heading">CSShake</h2>
                    <p class="text">
                        Результат выполнения класса shake-chunk
                    </p>
                </div>
                <div class="block d-block css-shake-chunk">
                    <h2 class="heading">CSShake</h2>
                    <p class="text">
                        Результат выполнения класса shake-chunk
                    </p>
                </div>
            </div>

            <h2 class="heading" id="magic.css">magic.css</h2>

            <p class="text">
                Для работы с библиотекой <span class="info">magic.css</span> необходимо получить экземпляр класса <span class="info">AnimationAssistant</span> и вызвать метод <span class="info">setLibrary</span>. Затем выбрать интересующую анимацию. Список всех анимация этой библиотеки можно посмотреть <a href="https://www.minimamente.com/project/magic/">на их сайте</a>. Для следующего примера будет использован класс <span class="info">slideDownReturn</span>. Сам элемент будет скрыт до начала анимации методом <span class="info">hideAtStart</span>, а анимацию запустит основной метод плагина <span class="info">setAnimation</span>.
            </p>

            <pre>
            <code>
            const magicCss = new AnimationAssistant('magic-css');
            magicCss.setLibrary('magic.css');
            magicCss.hideAtStart();
            magicCss.setAnimation(20, 'slideDownReturn');
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block magic-css">
                    <h2 class="heading">magic.css</h2>
                    <p class="text">
                        Результат выполнения класса slideDownReturn
                    </p>
                </div>
                <div class="block magic-css">
                    <h2 class="heading">magic.css</h2>
                    <p class="text">
                        Результат выполнения класса slideDownReturn
                    </p>
                </div>
            </div>

            <p class="text">
                Если вам нужно изменить время действия анимаций для этой библиотеки, то назначьте свое время создав CSS класс <span class="info">.magictime</span> и установив свойству <span class="info">animation-duration</span> интересующее вас значение. Например <span class="info">animation-duration: 3s</span> для более медленной анимации. Проблема заключается в том, что это будет действовать на все анимации. В нашем случае - на все экземпляры объекта <span class="info">AnimationAssistant</span>.
            </p>

            <p class="text">
                В остальном все работа с этой библиотекой схожа с <span class="info">animate.css</span>, которая детально разобрана выше.
            </p>

            <h2 class="heading" id="repaintless">repaintless.css</h2>

            <p class="text">
                Для работы с библиотекой <span class="info">repaintless.css</span> необходимо получить экземпляр класса <span class="info">AnimationAssistant</span> и вызвать метод <span class="info">setLibrary</span>. Затем выбрать интересующую анимацию. Список всех анимайция этой библиотеки можно посмотреть <a href="http://szynszyliszys.github.io/repaintless/">на их сайте</a>. Для следующего примера будет использован класс <span class="info">slide-from-top</span>. Сам элемент будет скрыт до начала анимации методом <span class="info">hideAtStart</span>, а анимацию запустит основной метод плагина <span class="info">setAnimation</span>.
            </p>

            <pre>
            <code>
            const repaintlessCss = new AnimationAssistant('repaintless-css');
            repaintlessCss.setLibrary('repaintless-css');
            repaintlessCss.hideAtStart();
            repaintlessCss.setAnimation(20, 'slide-from-top');
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block repaintless-css">
                    <h2 class="heading">repaintless.css</h2>
                    <p class="text">
                        Результат выполнения класса slide-from-top
                    </p>
                </div>
                <div class="block repaintless-css">
                    <h2 class="heading">repaintless.css</h2>
                    <p class="text">
                        Результат выполнения класса slide-from-top
                    </p>
                </div>
            </div>

            <p class="text">
                В остальном все работа с этой библиотекой схожа с <span class="info">animate.css</span>, которая детально разобрана выше.
            </p>

            <h2 class="heading" id="tuesday">tuesday</h2>

            <p class="text">
                Для работы с библиотекой <span class="info">tuesday</span> необходимо получить экземпляр класса <span class="info">AnimationAssistant</span> и вызвать метод <span class="info">setLibrary</span>. Затем выбрать интересующую анимацию. Список всех анимайция этой библиотеки можно посмотреть <a href="http://shakrmedia.github.io/tuesday/">на их сайте</a>. Для следующего примера будет использован класс <span class="info">tdPlopIn</span>. Сам элемент будет скрыт до начала анимации методом <span class="info">hideAtStart</span>, а анимацию запустит основной метод плагина <span class="info">setAnimation</span>.
            </p>

            <pre>
            <code>
            const tuesdayCss = new AnimationAssistant('tuesday-css');
            tuesdayCss.setLibrary('tuesday-css');
            tuesdayCss.hideAtStart();
            tuesdayCss.setAnimation(20, 'tdPlopIn');
            </code>
            </pre>

            <div class="section-demonstration">
                <div class="block tuesday-css">
                    <h2 class="heading">tuesday</h2>
                    <p class="text">
                        Результыт выполнения класса tdPlopIn
                    </p>
                </div>
                <div class="block tuesday-css">
                    <h2 class="heading">tuesday</h2>
                    <p class="text">
                        Результыт выполнения класса tdPlopIn
                    </p>
                </div>
            </div>

            <p class="text">
                В остальном все работа с этой библиотекой схожа с <span class="info">animate.css</span>, которая детально разобрана выше.
            </p>

            <h2 class="heading" id="other">Работа с другими CSS библиотеками для анимаций, которые не вошли в список</h2>

            <p class="text">
                Вы могли неувидеть выше любимую библиотеку CSS анимаций в списке выше. Это не означает, что данный плагин с нею не работает. Возможно они действительно могут быть не совместимы, но вы можете это проверить.
            </p>

            <p class="text">
                Все, что вам для этого нужно, это три метода экземпляра объекта <span class="info">AnimationAssistant</span> - <span class="info">addClasses</span>, <span class="info">play</span> и <span class="info">setAnimation</span>.
            </p>

            <p class="text">
                Для начала следует установить вашу библиотеку в проект. Затем нужно выбрать анимируемые элементы и присвоить им css класс. Его нужно будет передать конструктору <span class="info">AnimationAssistant</span>. Здесь все без изменений.
            </p>

            <pre>
            <code>
            const animated = new AnimationAssistant('your-selector');
            </code>
            </pre>

            <p class="text">
                В библиотеке вам нужно найти основной класс для работы с анимациями. Обычно он содержит два поля - <span class="info">animation-duration</span> и <span class="info">animation-fill-mode</span>. Например для библиотеки <span class="info">tuesday</span> это <span class="info">animated</span>, а для <span class="info">magic.css</span> это <span class="info">magictime</span>. Вызовите метод <span class="info">addClasses</span> и добавьте туда этот класс.
            </p>

            <pre>
            <code>
            const animated = new AnimationAssistant('your-selector');
            <span class="code-new">animated.addClasses(['your-class']);</span>
            </code>
            </pre>

            <p class="text">
                Далее следуйте документации библиотеки и выбирая интересующие вас классы добавляйте их в метод <span class="info">play</span> или <span class="info">setAnimation</span>.
            </p>

        </section>
    </main>

    <footer class="footer">
        (c) animation-assistant
    </footer>
</div>

</body>
</html>
